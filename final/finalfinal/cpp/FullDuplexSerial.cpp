//
// automatically generated by spin2cpp v1.06 on Thu Mar 26 03:46:33 2015
// spin2cpp BALAPILLER.spin 
//

#include <stdlib.h>
#include <propeller.h>
#include "FullDuplexSerial.h"

#ifdef __GNUC__
#define INLINE__ static inline
#define Yield__() __asm__ volatile( "" ::: "memory" )
#define PostEffect__(X, Y) __extension__({ int32_t tmp__ = (X); (X) = (Y); tmp__; })
#else
#define INLINE__ static
static int32_t tmp__;
#define PostEffect__(X, Y) (tmp__ = (X), (X) = (Y), tmp__)
#define Yield__()
#endif

INLINE__ int32_t Rotl__(uint32_t a, uint32_t b) { return (a<<b) | (a>>(32-b)); }
INLINE__ int32_t Rotr__(uint32_t a, uint32_t b) { return (a>>b) | (a<<(32-b)); }
INLINE__ int32_t Lookup__(int32_t x, int32_t b, int32_t a[], int32_t n) { int32_t i = (x)-(b); return ((unsigned)i >= n) ? 0 : (a)[i]; }

uint8_t FullDuplexSerial::dat[] = {
  0xf0, 0xa9, 0xbc, 0xa0, 0x10, 0xa8, 0xfc, 0x80, 0x54, 0xaa, 0xbc, 0x08, 0x01, 0xb2, 0xfc, 0xa0, 
  0x55, 0xb2, 0xbc, 0x2c, 0x04, 0xa8, 0xfc, 0x80, 0x54, 0xaa, 0xbc, 0x08, 0x01, 0xbe, 0xfc, 0xa0, 
  0x55, 0xbe, 0xbc, 0x2c, 0x04, 0xa8, 0xfc, 0x80, 0x54, 0xae, 0xbc, 0x08, 0x04, 0xa8, 0xfc, 0x80, 
  0x54, 0xb0, 0xbc, 0x08, 0x04, 0xa8, 0xfc, 0x80, 0x54, 0xb4, 0xbc, 0x08, 0x5a, 0xc0, 0xbc, 0xa0, 
  0x10, 0xc0, 0xfc, 0x80, 0x04, 0xae, 0x7c, 0x62, 0x02, 0xae, 0x7c, 0x61, 0x5f, 0xe8, 0x9b, 0x68, 
  0x5f, 0xec, 0xab, 0x68, 0x33, 0xc8, 0xfc, 0xa0, 0x64, 0xbc, 0xbc, 0x5c, 0x01, 0xae, 0x7c, 0x62, 
  0xf2, 0xb3, 0x3c, 0x61, 0x16, 0x00, 0x64, 0x5c, 0x09, 0xb8, 0xfc, 0xa0, 0x58, 0xba, 0xbc, 0xa0, 
  0x01, 0xba, 0xfc, 0x28, 0xf1, 0xbb, 0xbc, 0x80, 0x58, 0xba, 0xbc, 0x80, 0x64, 0xbc, 0xbc, 0x5c, 
  0x5d, 0xa8, 0xbc, 0xa0, 0xf1, 0xa9, 0xbc, 0x84, 0x00, 0xa8, 0x7c, 0xc1, 0x1f, 0x00, 0x4c, 0x5c, 
  0xf2, 0xb3, 0x3c, 0x61, 0x01, 0xb6, 0xfc, 0x30, 0x1e, 0xb8, 0xfc, 0xe4, 0x17, 0xb6, 0xfc, 0x28, 
  0xff, 0xb6, 0xfc, 0x60, 0x01, 0xae, 0x7c, 0x62, 0xff, 0xb6, 0xd4, 0x6c, 0xf0, 0xab, 0xbc, 0x08, 
  0x5a, 0xaa, 0xbc, 0x80, 0x55, 0xb6, 0x3c, 0x00, 0x5a, 0xaa, 0xbc, 0x84, 0x01, 0xaa, 0xfc, 0x80, 
  0x0f, 0xaa, 0xfc, 0x60, 0xf0, 0xab, 0x3c, 0x08, 0x16, 0x00, 0x7c, 0x5c, 0x5e, 0xc8, 0xbc, 0x5c, 
  0xf0, 0xa9, 0xbc, 0xa0, 0x08, 0xa8, 0xfc, 0x80, 0x54, 0xaa, 0xbc, 0x08, 0x04, 0xa8, 0xfc, 0x80, 
  0x54, 0xac, 0xbc, 0x08, 0x56, 0xaa, 0x3c, 0x86, 0x33, 0x00, 0x68, 0x5c, 0x60, 0xac, 0xbc, 0x80, 
  0x56, 0xc2, 0xbc, 0x00, 0x60, 0xac, 0xbc, 0x84, 0x01, 0xac, 0xfc, 0x80, 0x0f, 0xac, 0xfc, 0x60, 
  0x54, 0xac, 0x3c, 0x08, 0x00, 0xc3, 0xfc, 0x68, 0x02, 0xc2, 0xfc, 0x2c, 0x01, 0xc2, 0xfc, 0x68, 
  0x0b, 0xc4, 0xfc, 0xa0, 0xf1, 0xc7, 0xbc, 0xa0, 0x04, 0xae, 0x7c, 0x62, 0x02, 0xae, 0x7c, 0x61, 
  0x01, 0xc2, 0xe0, 0x6c, 0x01, 0xc2, 0xfc, 0x29, 0x5f, 0xe8, 0xab, 0x70, 0x5f, 0xec, 0x97, 0x74, 
  0x58, 0xc6, 0xbc, 0x80, 0x5e, 0xc8, 0xbc, 0x5c, 0x63, 0xa8, 0xbc, 0xa0, 0xf1, 0xa9, 0xbc, 0x84, 
  0x00, 0xa8, 0x7c, 0xc1, 0x4d, 0x00, 0x4c, 0x5c, 0x46, 0xc4, 0xfc, 0xe4, 0x33, 0x00, 0x7c, 0x5c, 
};
int32_t FullDuplexSerial::Start(int32_t Rxpin, int32_t Txpin, int32_t Mode, int32_t Baudrate)
{
  int32_t _parm__0000[4];
  int32_t Okay = 0;
  _parm__0000[0] = Rxpin;
  _parm__0000[1] = Txpin;
  _parm__0000[2] = Mode;
  _parm__0000[3] = Baudrate;
  Stop();
  { int32_t _fill__0023; int32_t *_ptr__0025 = (int32_t *)&Rx_head; int32_t _val__0024 = 0; for (_fill__0023 = 4; _fill__0023 > 0; --_fill__0023) {  *_ptr__0025++ = _val__0024; } };
  memmove( (void *)&Rx_pin, (void *)&_parm__0000[0], 4*(3));
  Bit_ticks = (CLKFREQ / _parm__0000[3]);
  Buffer_ptr = (int32_t)(&Rx_buffer);
  Okay = (Cog = (cognew((int32_t)(&(*(int32_t *)&dat[0])), (int32_t)(&Rx_head)) + 1));
  return Okay;
}

int32_t FullDuplexSerial::Stop(void)
{
  if (Cog) {
    cogstop((PostEffect__(Cog, 0) - 1));
  }
  { int32_t _fill__0026; int32_t *_ptr__0028 = (int32_t *)&Rx_head; int32_t _val__0027 = 0; for (_fill__0026 = 9; _fill__0026 > 0; --_fill__0026) {  *_ptr__0028++ = _val__0027; } };
  return 0;
}

int32_t FullDuplexSerial::Rxflush(void)
{
  while (Rxcheck() >= 0) {
    Yield__();
  }
  return 0;
}

int32_t FullDuplexSerial::Rxcheck(void)
{
  int32_t Rxbyte = 0;
  (Rxbyte--);
  if (Rx_tail != Rx_head) {
    Rxbyte = Rx_buffer[Rx_tail];
    Rx_tail = ((Rx_tail + 1) & 0xf);
  }
  return Rxbyte;
}

int32_t FullDuplexSerial::Rxtime(int32_t Ms)
{
  int32_t	T;
  int32_t Rxbyte = 0;
  T = CNT;
  while (!(((Rxbyte = Rxcheck()) >= 0) || (((CNT - T) / (CLKFREQ / 1000)) > Ms))) {
    Yield__();
  }
  return Rxbyte;
}

int32_t FullDuplexSerial::Rx(void)
{
  int32_t Rxbyte = 0;
  while ((Rxbyte = Rxcheck()) < 0) {
    Yield__();
  }
  return Rxbyte;
}

int32_t FullDuplexSerial::Tx(int32_t Txbyte)
{
  while (!(Tx_tail != ((Tx_head + 1) & 0xf))) {
    Yield__();
  }
  Tx_buffer[Tx_head] = Txbyte;
  Tx_head = ((Tx_head + 1) & 0xf);
  if (Rxtx_mode & 0x8) {
    Rx();
  }
  return 0;
}

int32_t FullDuplexSerial::Str(int32_t Stringptr)
{
  {
    int32_t _idx__0029;
    int32_t _limit__0030 = strlen((char *) Stringptr);
    for(_idx__0029 = 1; _idx__0029 <= _limit__0030; (_idx__0029 = (_idx__0029 + 1))) {
      Tx(((uint8_t *)(Stringptr++))[0]);
    }
  }
  return 0;
}

int32_t FullDuplexSerial::Dec(int32_t Value)
{
  int32_t	I, X;
  int32_t result = 0;
  X = -(Value == (int32_t)0x80000000U);
  if (Value < 0) {
    Value = (abs((Value + X)));
    Tx('-');
  }
  I = 1000000000;
  {
    int32_t _idx__0031;
    for(_idx__0031 = 1; _idx__0031 <= 10; (_idx__0031 = (_idx__0031 + 1))) {
      if (Value >= I) {
        Tx((((Value / I) + '0') + (X * -(I == 1))));
        Value = (Value % I);
        result = -1;
      } else {
        if ((result) || (I == 1)) {
          Tx('0');
        }
      }
      I = (I / 10);
    }
  }
  return result;
}

int32_t FullDuplexSerial::Hex(int32_t Value, int32_t Digits)
{
  static int32_t look__0032[] = {48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 65, 66, 67, 68, 69, 70, };

  Value = (Value << ((8 - Digits) << 2));
  {
    int32_t _idx__0033;
    int32_t _limit__0034 = Digits;
    for(_idx__0033 = 1; _idx__0033 <= _limit__0034; (_idx__0033 = (_idx__0033 + 1))) {
      Tx(Lookup__(((Value = (Rotl__(Value, 4))) & 0xf), 0, look__0032, 16));
    }
  }
  return 0;
}

int32_t FullDuplexSerial::Bin(int32_t Value, int32_t Digits)
{
  Value = (Value << (32 - Digits));
  {
    int32_t _idx__0035;
    int32_t _limit__0036 = Digits;
    for(_idx__0035 = 1; _idx__0035 <= _limit__0036; (_idx__0035 = (_idx__0035 + 1))) {
      Tx((((Value = (Rotl__(Value, 1))) & 0x1) + '0'));
    }
  }
  return 0;
}

