//
// automatically generated by spin2cpp v1.06 on Thu Mar 26 03:46:33 2015
// spin2cpp BALAPILLER.spin 
//

#include <stdlib.h>
#include <propeller.h>
#include "BALAPILLER.h"

#ifdef __GNUC__
#define INLINE__ static inline
#define PostEffect__(X, Y) __extension__({ int32_t tmp__ = (X); (X) = (Y); tmp__; })
#else
#define INLINE__ static
static int32_t tmp__;
#define PostEffect__(X, Y) (tmp__ = (X), (X) = (Y), tmp__)
#endif

static uint32_t LFSR__(uint32_t x, uint32_t forward) {
    uint32_t y, c, a;
    if (x < 1) x = 1;
    a = forward ? 0x8000000B : 0x17;
    for (y = 0; y < 32; y++) {
       c = __builtin_parity(x & a);
       if (forward) x = (x<<1) | c;
       else         x = (x>>1) | (c<<31);
    }
    return x;
}
#define RandForw__(x) ((x) = LFSR__((x), 1))
#define RandBack__(x) ((x) = LFSR__((x), 0))
int32_t BALAPILLER::Main(void)
{
  int32_t	I, Lastx, Lasty, Startballdir, Key, Inx;
  Sport.Start(_Rx, _Tx, 0, 19200);
  Soundcommand = 0;
  cognew(Makesound((int32_t)(&Soundcommand)), (int32_t)(&Stack));
  if (!(Screen.Pixenginestart(_Pingroup))) {
    clkset(0x80, 0);
  }
  waitcnt(((CLKFREQ * 2) + CNT));
  Startballdir = 1;
  Xball = (Screenwidth - (Screenwidth / 2));
  Yball = (Screenheight - (Screenheight / 4));
  Dirball = _Up;
  Plotball(Xball, Yball, Pen_draw);
  Ballinplay = Ball_in_play;
  Peron = (Ballspeed / Ballratio);
  Peroff = (Ballspeed - (Ballspeed / Ballratio));
  Balls = 1;
  Apples = 10;
  Acolor[0] = Screen.Displaycolor(3, 0, 0);
  Acolor[1] = Screen.Displaycolor(0, 3, 0);
  Acolor[2] = Screen.Displaycolor(3, 3, 0);
  Acolor[3] = Screen.Displaycolor(3, 0, 3);
  Acolor[4] = Screen.Displaycolor(0, 0, 3);
  Acolor[5] = Screen.Displaycolor(0, 3, 3);
  Acolor[6] = Screen.Displaycolor(3, 1, 0);
  Screen.Plotbox(Screen.Displaycolor(3, 2, 1), Min_x_coordinate, Min_y_coordinate, Max_x_coordinate, Max_y_coordinate);
  Screen.Plotbox(Screen.Displaycolor(0, 0, 0), (Min_x_coordinate + 1), (Min_y_coordinate + 1), (Max_x_coordinate - 1), (Max_y_coordinate - 1));
  cognew(Redrawborder(), (int32_t)(&Stack2));
  Placeapples();
  while (1) {
    Bound = Atboundary();
    Checkapples();
    if (Ballinplay == Ball_in_play) {
      Key = Getkeypressed();
      Dirball = Getnewdirection(Key, Dirball);
      Moveball();
      Updatesnake();
      Drawsnake();
      waitcnt(((CLKFREQ / Peron) + CNT));
    } else {
      if (Deadballtime < CNT) {
        Ballinplay = Ball_in_play;
        (Startballdir++);
        Xball = (Screenwidth / 2);
        Yball = (Screenheight - (Screenheight / 4));
        if (Startballdir & 0x1) {
          Dirball = _Up;
        } else {
          Dirball = _Up;
        }
        Updatesnake();
      }
    }
    if ((Bound != Not_at_boundary) || (Checkcollision() == 1)) {
      Ballinplay = Ball_out_of_play;
      Erasesnake();
      Soundcommand = Bad;
      Apples = 10;
      Placeapples();
      Xeraseball = 0;
      Yeraseball = 0;
      Xoldball = 0;
      Yoldball = 0;
      Xball = (Screenwidth - (Screenwidth / 2));
      Yball = (Screenheight - (Screenheight / 4));
      Deadballtime = ((CLKFREQ * Ball_back_in_play_delay) + CNT);
    }
  }
  return 0;
}

int32_t BALAPILLER::Atboundary(void)
{
  int32_t Theboundary = 0;
  if (((Xball == Min_x_coordinate) || ((Xball + 1) == Min_x_coordinate)) || ((Xball - 1) == Min_x_coordinate)) {
    Theboundary = Lw;
  } else {
    if (((Xball == Max_x_coordinate) || ((Xball + 1) == Max_x_coordinate)) || ((Xball - 1) == Max_x_coordinate)) {
      Theboundary = Rw;
    } else {
      if (((Yball == Min_y_coordinate) || ((Yball + 1) == Min_y_coordinate)) || ((Yball - 1) == Min_y_coordinate)) {
        Theboundary = Tw;
      } else {
        if (((Yball == Max_y_coordinate) || ((Yball + 1) == Max_y_coordinate)) || ((Yball - 1) == Max_y_coordinate)) {
          Theboundary = Bw;
        } else {
          Theboundary = Not_at_boundary;
        }
      }
    }
  }
  return Theboundary;
}

int32_t BALAPILLER::Plotball(int32_t X, int32_t Y, int32_t K)
{
  int32_t	Ran;
  if (K == Pen_erase) {
    Screen.Plotbox(Screen.Displaycolor(0, 0, 0), (X - 1), (Y - 1), (X + 1), (Y + 1));
  } else if (K == Pen_draw) {
    Ran = CNT;
    Screen.Plotbox(Acolor[(abs(((RandForw__(Ran)) % 7)))], (X - 1), (Y - 1), (X + 1), (Y + 1));
  }
  return 0;
}

int32_t BALAPILLER::Plotapple(int32_t X, int32_t Y, int32_t K, int32_t Num)
{
  int32_t	Applecolor, Ran, Ranc1, Ranc2, Ranc3;
  if (Num == 1) {
    Applecolor = Acolor[(Num - 1)];
  } else if (Num == 2) {
    Applecolor = Acolor[(Num - 1)];
  } else if (Num == 3) {
    Applecolor = Acolor[(Num - 1)];
  } else if (Num == 4) {
    Applecolor = Acolor[(Num - 1)];
  } else if (Num == 5) {
    Applecolor = Acolor[(Num - 1)];
  } else if (Num == 6) {
    Ran = CNT;
    Applecolor = Acolor[(abs(((RandForw__(Ran)) % 7)))];
  }
  if (K == Pen_erase) {
    Screen.Plotbox(Screen.Displaycolor(0, 0, 0), (X - 1), (Y - 1), (X + 1), (Y + 1));
  } else if (K == Pen_draw) {
    Screen.Plotbox(Applecolor, (X - 1), Y, (X + 1), (Y + 1));
    Screen.Plotpixel(Screen.Displaycolor(0, 1, 0), X, (Y - 1));
  }
  return 0;
}

int32_t BALAPILLER::Getkeypressed(void)
{
  int32_t	Updown;
  Updown = Sport.Rxcheck();
  if (Updown == Upchar) {
    Updown = Up;
  } else if (Updown == Dnchr2) {
    Updown = Down;
  } else if (Updown == Dnchar) {
    Updown = Down;
  } else if (Updown == Ltchar) {
    Updown = Left;
  } else if (Updown == Rtchar) {
    Updown = Right;
  } else if (1) {
    Updown = 0;
  }
  return Updown;
}

int32_t BALAPILLER::Getnewdirection(int32_t Whichkey, int32_t Olddirection)
{
  int32_t Newdirection = 0;
  Ballinc = 0;
  if (Whichkey == Up) {
    if ((Olddirection != _Up) && (Olddirection != _Dn)) {
    }
    if (Olddirection != _Dn) {
      Newdirection = _Up;
    } else {
      Newdirection = _Dn;
    }
  } else if (Whichkey == Down) {
    if ((Olddirection != _Dn) && (Olddirection != _Up)) {
    }
    if (Olddirection != _Up) {
      Newdirection = _Dn;
    } else {
      Newdirection = _Up;
    }
  } else if (Whichkey == Left) {
    if ((Olddirection != _Lt) && (Olddirection != _Rt)) {
    }
    if (Olddirection != _Rt) {
      Newdirection = _Lt;
    } else {
      Newdirection = _Rt;
    }
  } else if (Whichkey == Right) {
    if ((Olddirection != _Rt) && (Olddirection != _Lt)) {
    }
    if (Olddirection != _Lt) {
      Newdirection = _Rt;
    } else {
      Newdirection = _Lt;
    }
  } else if (1) {
    return Olddirection;
  }
  return Newdirection;
}

int32_t BALAPILLER::Moveball(void)
{
  Xoldball = Xball;
  Yoldball = Yball;
  if (Dirball == _Up) {
    Yball = (Yball - 3);
  } else if (Dirball == _Dn) {
    Yball = (Yball + 3);
  } else if (Dirball == _Lt) {
    Xball = (Xball - 3);
  } else if (Dirball == _Rt) {
    Xball = (Xball + 3);
  }
  return 0;
}

int32_t BALAPILLER::Updatesnake(void)
{
  int32_t	Index;
  if (Balls < 2) {
    Xeraseball = Xoldball;
    Yeraseball = Yoldball;
  }
  if (Balls > 1) {
    Xeraseball = Xsnake[(Balls - 1)];
    Yeraseball = Ysnake[(Balls - 1)];
  }
  Index = (Balls - 1);
  while (Index > 0) {
    Xsnake[Index] = Xsnake[(Index - 1)];
    Ysnake[Index] = Ysnake[(Index - 1)];
    (Index--);
  }
  Xsnake[0] = Xball;
  Ysnake[0] = Yball;
  return 0;
}

int32_t BALAPILLER::Drawsnake(void)
{
  Plotball(Xsnake[0], Ysnake[0], Pen_draw);
  if (Ballinc == 0) {
    Plotball(Xeraseball, Yeraseball, Pen_erase);
  }
  return 0;
}

int32_t BALAPILLER::Erasesnake(void)
{
  int32_t	Ix, Xx, Yy;
  {
    int32_t _limit__0001 = (Balls - 1);
    int32_t _step__0002 = 1;
    Ix = 0;
    if (Ix >= _limit__0001) _step__0002 = -_step__0002;
    do {
      Plotball(Xsnake[Ix], Ysnake[Ix], Pen_erase);
      Ix = (Ix + _step__0002);
    } while (((_step__0002 > 0) && (Ix <= _limit__0001)) || ((_step__0002 < 0) && (Ix >= _limit__0001)));
  }
  Balls = 1;
  Screen.Plotbox(Screen.Displaycolor(0, 0, 0), (Min_x_coordinate + 1), (Min_y_coordinate + 1), (Max_x_coordinate - 1), (Max_y_coordinate - 1));
  return 0;
}

int32_t BALAPILLER::Redrawborder(void)
{
  int32_t	Xx, Yy;
  while (1) {
    Xx = Min_x_coordinate;
    do {
      Screen.Plotpixel(Screen.Displaycolor(3, 2, 1), Xx, Min_y_coordinate);
      Screen.Plotpixel(Screen.Displaycolor(3, 2, 1), Xx, Max_y_coordinate);
      Xx = (Xx + 1);
    } while (Xx <= 156);
    Yy = Min_y_coordinate;
    do {
      Screen.Plotpixel(Screen.Displaycolor(3, 2, 1), Min_x_coordinate, Yy);
      Screen.Plotpixel(Screen.Displaycolor(3, 2, 1), Max_x_coordinate, Yy);
      Yy = (Yy + 1);
    } while (Yy <= 116);
  }
  return 0;
}

int32_t BALAPILLER::Checkcollision(void)
{
  int32_t	Collide, Idx;
  Collide = 0;
  if (Balls > 1) {
    {
      int32_t _limit__0003 = (Balls - 1);
      int32_t _step__0004 = 1;
      Idx = 2;
      if (Idx >= _limit__0003) _step__0004 = -_step__0004;
      do {
        if ((Xsnake[Idx] == Xball) && (Ysnake[Idx] == Yball)) {
          Collide = 1;
        }
        Idx = (Idx + _step__0004);
      } while (((_step__0004 > 0) && (Idx <= _limit__0003)) || ((_step__0004 < 0) && (Idx >= _limit__0003)));
    }
  }
  return Collide;
}

int32_t BALAPILLER::Placeapples(void)
{
  int32_t	Index, X, Ran, Z;
  Ran = CNT;
  {
    int32_t _limit__0005 = (Apples - 1);
    int32_t _step__0006 = 1;
    Index = 0;
    if (Index >= _limit__0005) _step__0006 = -_step__0006;
    do {
      Xapple[Index] = (5 + ((abs((((RandForw__(Ran)) % 148) / 3))) * 3));
      Yapple[Index] = (6 + ((abs((((RandForw__(Ran)) % 108) / 3))) * 3));
      Apple[Index] = 1;
      {
        int32_t _limit__0007 = (Apples - 1);
        int32_t _step__0008 = 1;
        X = 0;
        if (X >= _limit__0007) _step__0008 = -_step__0008;
        do {
          while (((Xapple[X] == Xapple[Index]) && (Yapple[X] == Yapple[Index])) && (Index != X)) {
            Xapple[Index] = (5 + ((abs((((RandForw__(Ran)) % 148) / 3))) * 3));
            Yapple[Index] = (6 + ((abs((((RandForw__(Ran)) % 108) / 3))) * 3));
          }
          X = (X + _step__0008);
        } while (((_step__0008 > 0) && (X <= _limit__0007)) || ((_step__0008 < 0) && (X >= _limit__0007)));
      }
      {
        int32_t _limit__0009 = (Balls - 1);
        int32_t _step__0010 = 1;
        Z = 0;
        if (Z >= _limit__0009) _step__0010 = -_step__0010;
        do {
          while ((Xsnake[Z] == Xapple[Index]) && (Ysnake[Z] == Yapple[Index])) {
            Xapple[Index] = (5 + ((abs((((RandForw__(Ran)) % 148) / 3))) * 3));
            Yapple[Index] = (6 + ((abs((((RandForw__(Ran)) % 108) / 3))) * 3));
          }
          Z = (Z + _step__0010);
        } while (((_step__0010 > 0) && (Z <= _limit__0009)) || ((_step__0010 < 0) && (Z >= _limit__0009)));
      }
      if (Apples == 10) {
        Plotapple(Xapple[Index], Yapple[Index], Pen_draw, 1);
      }
      if (Apples == 20) {
        Plotapple(Xapple[Index], Yapple[Index], Pen_draw, 2);
      }
      if (Apples == 30) {
        Plotapple(Xapple[Index], Yapple[Index], Pen_draw, 3);
      }
      if (Apples == 40) {
        Plotapple(Xapple[Index], Yapple[Index], Pen_draw, 5);
      }
      if (Apples > 40) {
        Plotapple(Xapple[Index], Yapple[Index], Pen_draw, 6);
      }
      if (Apples > 10) {
        Soundcommand = Good;
        waitcnt(((CLKFREQ / 10) + CNT));
      }
      Index = (Index + _step__0006);
    } while (((_step__0006 > 0) && (Index <= _limit__0005)) || ((_step__0006 < 0) && (Index >= _limit__0005)));
  }
  return 0;
}

int32_t BALAPILLER::Checkapples(void)
{
  int32_t	Index, Appledone, Ran;
  Appledone = 1;
  {
    int32_t _limit__0011 = (Apples - 1);
    int32_t _step__0012 = 1;
    Index = 0;
    if (Index >= _limit__0011) _step__0012 = -_step__0012;
    do {
      if (((Xball == Xapple[Index]) && (Yball == Yapple[Index])) && (Apple[Index] == 1)) {
        Apple[Index] = 0;
        (Balls++);
        Ballinc = 1;
        Soundcommand = Good;
      }
      if (Apple[Index] == 1) {
        Appledone = 0;
      }
      Index = (Index + _step__0012);
    } while (((_step__0012 > 0) && (Index <= _limit__0011)) || ((_step__0012 < 0) && (Index >= _limit__0011)));
  }
  if (Appledone == 1) {
    Apples = (Apples + 10);
    if (Apples == 50) {
      Erasesnake();
      while (1) {
        Ran = CNT;
        Soundcommand = Good;
        waitcnt(((CLKFREQ / 10) + CNT));
        Xapple[Index] = (5 + ((abs((((RandForw__(Ran)) % 148) / 3))) * 3));
        Yapple[Index] = (6 + ((abs((((RandForw__(Ran)) % 108) / 3))) * 3));
        Plotapple(Xapple[Index], Yapple[Index], Pen_draw, 6);
      }
    }
    Placeapples();
  }
  return 0;
}

int32_t BALAPILLER::Makesound(int32_t Command)
{
  int32_t	A;
  while (1) {
    if (((int32_t *)Command)[0] != 0) {
      int32_t _tmp__0013 = ((int32_t *)Command)[0];
      if (_tmp__0013 == Good) {
        A = 100;
        do {
          Synth.Synth('A', 10, A);
          Synth.Synth('B', 11, (A + 1000));
          A = (A + 50);
        } while (A <= 2000);
      } else if (_tmp__0013 == Bad) {
        {
          int32_t _idx__0014;
          for(_idx__0014 = 1; _idx__0014 <= 3; (_idx__0014 = (_idx__0014 + 1))) {
            A = 2000;
            do {
              Synth.Synth('A', 10, A);
              Synth.Synth('B', 11, (A + 1000));
              A = (A + -50);
            } while (A >= 100);
          }
        }
        waitcnt(((CLKFREQ / 2) + CNT));
      }
      CTRA = 0;
      CTRB = 0;
      ((int32_t *)Command)[0] = 0;
    }
  }
  return 0;
}

